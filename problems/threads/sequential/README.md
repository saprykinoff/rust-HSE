# Sequential

### О чем задача?

В том или ином виде эта задача возникает достаточно часто на собеседованиях, когда речь заходит о многопоточности. Один из популярных вариантов формулировок устроен так:

_Дано два потока, где первый поток последовательно выводит четные числа, а второй поток - последовательные нечетные числа. Нужно написать программу, которая выводит все числа поочередно из каждого потока_

Суть задачи состоит в умелом обращении с потоками и настройки общения между потоками. Хорошая реализация такой задачи использует `conditional_variable`, но это отдельная тема для изучения и встретится вам более подробно в других курсах. В этой же задаче требуется реализовать слегка измененную логику.

### Что нужно сделать

Вам нужно имплементировать функцию `sequential_run<Printer, Iter>`, где `Printer` это `Fn`-замыкание, принимающую на вход ссылку на текущий `thread` и элементы итератора `Iter`. Внутри этой функции надо создать два потока, с именами `odd thread` (для нечетного потока) и `even thread` (для четного потока). Каждый из потоков будет идти по итератору, но нечетный поток будет ходить только по нечетным индексам итератора, а четный поток - только по четным индексам итератора (нумерация с нуля). Также внутри этих потоков для каждого элемента итератора нужно вызывать `printer`, передавая в него ссылку на `thread::current()` и непосредственно элемент итератора. Поток должен представлять из себя бесконечный цикл, который на каждой итерации сначала спит `odd_ms` или `even_ms` миллисекунд в зависимости от четности потока, а затем выполняет логику. Останавливается поток только если суммарное количество пройденных элементов стало равным или превысило `max_iterations` или если итератор закончился. Примеры можно посмотреть в тестах.

### На что стоит обратить внимание

Как обратится к итератору из потоков, избежав гонки данных? Как запомнить, что один из потоков еще не завершил свою работу и не обратился к элементу итератора своей четности?
