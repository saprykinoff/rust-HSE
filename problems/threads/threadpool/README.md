# ThreadPool

### Что такое ThreadPool

**ThreadPool** это структура данных, которая контролирует создаваемые программой потоки и запускает заданные задачи в этих отдельных потоках.
Можно представить себе ситуацию, когда у вас есть большой набор одинаковых функций,
которые вы хотите выполнить, при этом их одновременное выполнение разрешено;
также у вас имеются работники, которые могут эти функции выполнять. В такой ситуации не хватает менеджера, 
который взял бы на себя обязательства:
- назначать функции на свободных работников,
- следить за выполнением задач у каждого работника
- использовать работников рационально, т.е. оптимально раздавать им задачи

Таким менеджером и выступает **ThreadPool**. Существует большое множество различных вариаций реализаций для ThreadPool-а,
но в этой задаче вам предстоит реализовать простейший вид, в котором имеется только один вид работ и заданное количество потоков.

### Что нужно в задаче

Вам нужно дописать код, имплементирующий структуру `ThreadPool`.
Конструктор `new` должен принимать число `size`,
указывающее на количество создаваемых задач (`ThreadTask`).
`ThreadTask` это объект, который получает при создании на вход
свой `id` (номер от `0` до `size`) и `receiver` - канал,
через который будет поступать сообщение `Message<Job>` 
о новой задаче с этой задачею (`Message::NewJob(job)`)
или сообщение o завершении работы (`Message::Terminate`).
Каждый поток должен именоваться `Task {id}` (без фигурных скобок).

### Подробнее об объектах

- `Job` - это `FnOnce()` замыкание, которое можно передавать в потоки
- `ThreadTask` - это структура c единственным методом `new(id, receiver)`,
                , которая создает поток в режиме прослушивания `receiver`-а,
                то есть поток в бесконечном цикле слушает `receiver` и когда получает
                `Message` - выполняет его.
- `ThreadPool` - это структура с методами:
    - `new(size)` - создает `ThreadPool` с указанным количеством `ThreadTask`,
                    создает канал связи с потоками через `mpsc::channel`
    - `execute(job)` - отправляет в канал сообщение о наличии новой работы
                    `Message::NewJob(...)`
    - `drop()` - деструктор для `ThreadPool`, который посылает в канал `size` сообщений `Message::Terminate`, а затем дожидается завершения всех потоков.
- `Message<Job>` - это `enum` с двумя значениями - `NewJob(...)` и `Terminate`. Поле `NewJob` содержит в себе `Job` для выполнения этой функции.

### Канал связи между потоками

Канал это популярный способ обменом информации между потоками.
Мы будем передавать сообщения из `ThreadPool` (главного потока) в 
`ThreadTask`-потоки (дочерние). Для этого в Rust есть стандартная библиотека [mpsc](https://doc.rust-lang.org/std/sync/mpsc/),
которая позволяет создать такой канал через

```rust
let (sender, receiver) = mpsc::channel();
```

У объекта `sender` есть метод `.send(msg)`, отправляющий объект `msg` по каналу.
А у объекта `receiver` метод `.recv()`, возвращающий `Result<msg, Error>`.
В этой домашней работе вы можете распаковать сообщение без обработки ошибок, сделав

```rust
let msg = receiver.recv().unwrap();
```

Проблема состоит в том, что `receiver` один, а дочерних потоков много.
Подумайте, как сделать так, чтобы каналы не конкурировали друг с другом за чтение,
а вызов метода `.recv()` был безопасным с точки зрения `data race`.


### Именование потоков

Чтобы проименовать создаваемый поток, воспользуйтесь соответствующей конструкцией:

```rust
let thread = std::thread::Builder::new()
                .name(thread_name)
                .spawn(|| {})
                .unwrap();
```

