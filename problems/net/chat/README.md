# Chat

В этой задаче нужно написать сервер для общения клиентов между собой.
К серверу могут присоединиться сразу множество клиентов-участников.
Присоединившись к серверу, любой участник может написать сообщение любому другому активному участнику.

## Протокол

Дадим неформальное описание протокола взаимодействия.

Каждый участник, присоединившись к серверу, должен сначала представиться.
Для этого он пишет свое имя, в конце ставя байт со значением `1u8` (так называемый `SOH`-символ) - это будет разделитель всех сообщений в нашем протоколе.

После того как участник представился, любой другой зарегестрированный участник может отправить ему сообщение.
Сам он, конечно, тоже может отправлять сообщения другим участникам.

Как только участник закрывает/теряет соединение с сервером или сервер не может прочитать его команды, он вычеркивается из списка участников и к нему больше нельзя обратиться.
Однако, он, конечно, может переподсоединиться под тем же именем и продолжать получать сообщения (но все сообщения, отправленные пока не был в системе пропадут).

Отправка сообщений выглядит таким образом.
Сначала клиент посылает имя другого клиента, к которому он хочет обратиться, **но не к самому себе**.
Затем ставит символ SOH (байт `1`).
После чего пишет свое сообщение произвольной длины и заканчивает его все тем же символом SOH.

*Примечание*. Имя участника и текст сообщений могут состоять из **произвольного набора байт**, за исключением байта `SOH`.

Сервер же, со своей стороны, получает это сообщение и отправляет его адресату.
Сначала адресату пишется имя отправителя, затем идет символ SOH, затем само сообщение и все снова завершается символом SOH.
Если адресата с таким именем не существует сейчас в системе, то сообщение уничтожается и не достается никому.

## Особые случаи

- Если во время чтения очередного сообщения от клиента поток чтения неожиданно завершился (был получен [EOF](https://en.wikipedia.org/wiki/End-of-file) или соединение оборвалось до получения байта SOH), то текущую команду сервер должен пропустить и не выполнять, а клиент должен быть удален из системы.
  Соответственно, если это была передача имени клиента, то клиент не должен быть зарегестрирован, а если это была передача сообщения, то это сообщение не должно быть отправлено.
- Если одному участнику одновременно передается два сообщения, то они могут быть записаны в любом порядке, но **поочередно** (сначала целиком одно, затем целиком другое).
- При сомнениях смотрите тесты. Если тестов на интересующий кейс нет, то спросите в чате или делайте по своему усмотрению.

## Допущения

- Можно считать, что новые клиенты не представляются именами других активных в данный момент клиентов.

## Подсказки/Рекомендации

- Если вам показалось, что задача сложная, то вам показалось. Кода в решении немного и ничего принципиально нового (чего не было в предыдущих задачах) в нем нет.
- В этой задаче и в соседней не стоит выводить ничего в поток `stdout`, иначе можно получить ошибку со словами `"Broken pipe"` при запуске `rover test`.
  Для дебажного или какого-либо другого вспомогательного вывода можете использовать поток `stderr`. См. также следующий пункт.
- Для дебага/вывода можете воспользоваться удобными макросами `info!`, `warn!`, `debug!`, `error!` для логирования (уже импортированы в шаблоне).
  Они чуть скрасят вашу дебажную жизнь.
- Чтобы при запуске тестов были видны выводы в `stderr` и `stdout`, запустите тесты с флагом `--nocapture`:

  ```sh
  $ cargo test -- --nocapture
  ```

- Запустить сервер можно следующей командой:

  ```sh
  $ cargo run -- --ip 127.0.0.1 --port 7878
  ```

  Она запустит сервер на порте 7878.

- Для ручного тестирования можно воспользоваться консольной утилитой [`nc`](https://en.wikipedia.org/wiki/Netcat) (Netcat).
  Через нее можно имитировать клиента для вашего сервера.
  Просто подключитесь к серверу через команду
  
  ```sh
  $ nc <ip> <port>
  $ # например
  $ nc 127.0.0.1 7878
  ```

  А дальше вводите команды будто вы клиент вашего сервера.
  Введите имя участника и передавайте сообщения другим участникам (для каждого участника надо запустить отдельный `nc`).
  Добавьте логирование в вашем коде, чтобы видеть как ваш сервер реагирует на определенные действия со стороны клиента (подключение, ввод имени, сообщений и тп).
- Для дебага также удобно будет временно заменить разделитель с символа SOH на какой-нибудь, который легко ввести с клавиатуры (например, перевод строки `\n` aka Enter).
  Запишите символ разделителя в коде в виде константы, чтобы переключение между разными символами было проще.
- Для удобного чтения данных из `TcpStream` можно воспользоваться [`BufReader`](https://doc.rust-lang.org/stable/std/io/struct.BufReader.html)-ом и его методом [`read_until`](https://doc.rust-lang.org/stable/std/io/trait.BufRead.html#method.read_until).
- Из условия вытекает то, что сервер должен работать с клиентами параллельно.
  Можете создать по треду (`thread::spawn`) для работы с каждым клиентом.
  Ждать завершения тредов (`join`) и проверять успешность их завершения необязательно.
  Некоторые переменные придется иметь в каждом треде: вспомните предыдущие ДЗ и какие примитивы синхронизации вы там использвали.
- Наверняка вам понадобится использовать один `TcpStream` в одном потоке для чтения, а в другом(-их) потоке(-ах) для записи.
  Это возможно: для этого вам понадобится склонировать `TcpStream` через метод [`try_clone()`](https://doc.rust-lang.org/stable/std/net/struct.TcpStream.html#method.try_clone).
