# Rock paper scissors

В данной задаче вам предстоит написать сервер для игры в [камень, ножницы, бумагу](https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D0%BC%D0%B5%D0%BD%D1%8C,_%D0%BD%D0%BE%D0%B6%D0%BD%D0%B8%D1%86%D1%8B,_%D0%B1%D1%83%D0%BC%D0%B0%D0%B3%D0%B0).

Схема такая.
Два клиента подключаются к серверу, который последовательно проводит раунды игры.
Каждый раунд клиенты отправляют серверу свой ход, после чего сервер подводит итоги раунда и сообщает результаты обоим игрокам.

Вы должны написать код сервера в соответствии с правилами игры и протоколом, описанным ниже.

## Протокол

Для общения между клиентами и сервером мы выберем протокол TCP, о нем мы узнали подробно на лекции.

Для начала игры два клиента должны установить TCP-соединение с сервером, после чего они могут начать отправлять ему сообщения (свои ходы) и принимать сообщения от сервера для получения итогов раундов.

### Формат сообщений

В нашем протоколе обмена информацией будет два типа сообщений:

1. `Turn(u8)` - один байт, кодирующий ход. Возможные значения: `b'R'` (`82u8`), `b'P'` (`80u8`), `b'S'` (`83u8`).
2. `Report(u8, u8)` - два байта, первый кодирует ход соперника в этом раунде, второй байт кодирует результат.
   При выигрыше в раунде участник вторым байтом получает `b'W'` (`87u8`), при проигрыше `b'L'` (`76u8`), при ничье `b'D'` (`68u8`).

Разделителей между сообщениями нет.

### Работа клиентов

Реализовывать клиентов в этой задаче не нужно, но важно понимать логику их работы.
Пример реализации клиентов можно посмотреть в тесты.

1. В начале клиент подключается к серверу, устанавливая TCP-соединение с ним.
1. Дальше клиент отправляет серверу свой первый ход, то есть сообщение типа `Turn` (по сути один байт).
1. Клиент ждет результата раунда, то есть получает от сервера сообщение типа `Report` (два байта).
1. Начинается новый раунд, клиент переходит к пункту 2.
1. Раунды повторяются, пока сервер не оборвет/закроет соединение.
   Также клиент может сам в любой момент закрыть соединение.

### Работа сервера

Эту часть уже придется реализовать вам самим.

Сервер должен работать следующим образом.

1. Сервер в функции `run` (в [src/lib.rs](./src/lib.rs)) начинает прослушивать соединения по заданной паре `(ip, port)`.
1. Сервер может принять максимум два соединения (двух игроков). Все другие новые соединения не должны приниматься.
1. Как только сервер устанавливает два соединения, начинается игра.
   Сервер принимает ходы (сообщения типа `Turn`) от каждого из клиентов.
1. Сервер вычисляет результат раунда и сообщает его обоим игрокам путем передачи сообщения типа `Report`.
1. Если какой-то из игроков отправляет невалидные сообщения, то сервер закрывает соединения и завершает свою работу.
1. Также сервер завершает свою работу, когда любой из клиентов обрывает/завершает соединение.

*Замечание*. После закрытия соединения с любой из сторон игра заканчивается,
начать заново игру уже нельзя (только перезапустив сервер).

## Подсказки/Дополнительная информация

- В этой задаче и в соседней не стоит выводить ничего в поток `stdout`, иначе можно получить ошибку со словами `"Broken pipe"` при запуске `rover test`.
  Для дебажного или какого-либо другого вспомогательного вывода можете использовать поток `stderr`.
- Функция `run` принимает переменную `ip` с типом [`IpAddr`](https://doc.rust-lang.org/stable/std/net/enum.IpAddr.html).
  Этот тип удобно использовать для хранения ip адресов там, где может ожидаться как IPv4, так и IPv6 адрес.
- Для получения полного адреса (пара `<ip>:<port>`) необязательно создавать строку,
  правильнее будет создать переменную типа [`SocketAddr`](https://doc.rust-lang.org/stable/std/net/enum.SocketAddr.html), которую можно уже передать в [`TcpListener::bind`](https://doc.rust-lang.org/stable/std/net/struct.TcpListener.html#method.bind).
- Посмотрите [подсказки](../chat/README.md#подсказкирекомендации) из соседней задачи, многие из них так же применимы и к этой задаче.
