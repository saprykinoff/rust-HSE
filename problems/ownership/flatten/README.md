# Flatten

## Условие

В файле `src/lib.rs` находится две функции, которые Вам нужно имплементировать. 

Первая функция - `transform_to_fixed_arr` является generic-ом и в своём интерфейсе схожа с шаблонами в C++. Целочисленный параметр `N`, передаваемый ей в треугольных скобках, будет служить размером массива. Параметр функции - мьютабельная ссылка на вектор векторов целочисленного типа. Результирующий же тип представляет из себя вектор указателей на массивы фиксированного размера, где каждый элемент массива - мьютабельная ссылка на соответствующий элемент в векторе исходных данных, т.е. схематически функция производит трансформацию следующего вида:

```rust
vec![                                                vec![
    vec![x_1, x_2, x_3],                                  Box([&mut x_1, &mut x_2, &mut x_3]),
    vec![x_4, x_5, x_6],                     ==>          Box([&mut x_4, &mut x_5, &mut x_6]),
    vec![x_7, x_8, x_9],                                  Box([&mut x_7, &mut x_8, &mut x_9]),
]                                                    ]
```

В случае, когда на вход подается список векторов с неподходящими размерами, то есть не равными `N`, функция должна вызвать панику со строчкой `"Inner vectors are of different size"`.

Вторая функция (`flatten`) принимает на вход данные в формате результата предыдущей функции и превращает двумерные данные в одномерные, то есть схематически функция выглядит следующим образом 

```rust
vec![                                                vec![
    Box([&mut x_1, &mut x_2, &mut x_3]),                 &mut x_1, &mut x_2, &mut x_3,
    Box([&mut x_4, &mut x_5, &mut x_6]),      ==>        &mut x_4, &mut x_5, &mut x_6,
    Box([&mut x_7, &mut x_8, &mut x_9]),                 &mut x_7, &mut x_8, &mut x_9,
]                                                    ]
```

В тестах (в файле `tests/tests.rs`) можно найти примеры использования таких функций. Будьте осторожны в работе с мьютабельными ссылками - эти типы нетривиально копируемы (вы не можете иметь две копии мьютабельных ссылок одновременно), поэтому вас ждёт много сложностей прохождения borrow-checker-а.

### Теоретическая справка
- `Box` - это умные указатели в rust, то есть инструмент, который позволяет аллоцировать данные не на стеке, а на куче. `Box` имеют только одного владельца (аналог `unique_ptr` в C++). Чтобы инициализировать переменную типа `Box`, достаточно написать
    ```rust
    let var: Box<i32> = Box::new(10);
    ```
    Указатель можно разыменовать с помощью оператора `*`, например
    ```rust
    let inner_ref: &i32 = &(*var);
    ```
- Оба типа `Vec<i32>` и `Box<[i32; N]>` аллоцированны на куче, но первый тип изменяем в длине, а второй тип имеет константную длину.
- Для конвертации `Vec<i32>` в массив `[i32; N]` Вы можете воспользоваться конструкцией `try_into().unwrap()`

#### Документация
- [Про `Box`](https://doc.rust-lang.org/std/boxed/struct.Box.html)
- [Про `Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html)
