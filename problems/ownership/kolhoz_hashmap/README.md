# Kolhoz MultiHashMap

Напишите реализацию функций для работы с хеш-таблицей в файле [src/hashmap.rs](src/hashmap.rs).

## Детали устройства колхозной хеш-таблицы

В задаче требуется, чтобы хеш-таблица удовлетворяла следующим условиям/правилам:

- Хеш-таблица состоит из `n` бакетов. Каждый бакет - это вектор пар ключ-значение `(Key, Data)`. В бакете хранятся элементы с одинаковым хеш-значением ключа (по модулю размера таблицы).
- Данные с ключом `k: Key` находятся в бакете с номером `hash(k) % table.len()`.
- В хеш-таблице могут содержаться несколько значений с одинаковым ключом, то есть колхозная хеш-таблица на самом деле является мульти-хеш-таблицей.
- Перехеширование таблицы происходит только по явному запросу - по вызову функции `resize`.

Типы ключа и значения объявлены в файле [src/types.rs](src/types.rs).

- С типами Key и Data, как следует из их описания, можно делать довольно ограниченное число действий, а именно:
  - [форматировать для debug-вывода](https://doc.rust-lang.org/std/fmt/trait.Debug.html)
  - [сравнивать на равенство](https://doc.rust-lang.org/std/cmp/trait.Eq.html)
  - тип `Key` также является hashable, то есть от значения ключа можно посчитать хеш
- Хеш-значение ключа можно получить через метод [key.get_hash()](src/types.rs#L13).

## Функции

Нужно реализовать следующие функции с объявленным сигнатурами в файле [src/hashmap.rs](src/hashmap.rs).

__*Примечание*__. Сигнатуры функций могут быть даны неполными. В частности, в некоторых функциях нужно правильно аннотировать ссылки лайфтаймами.

### `new_hashmap`

```rust
pub fn new_hashmap(len: usize) -> Vec<Vec<(Key, Data)>>;
```

Функция должна создать пустую хеш-таблицу с размером `len`.

### `insert`

```rust
pub fn insert(table: &mut Vec<Vec<(Key, Data)>>, key: Key, value: Data) -> &mut Data;
```

Добавляет в хеш-таблицу `table` значение `value` с ключом `key`.
После вставки значения нужно вернуть ссылку на него в хеш-таблице.

При вставке в пустую таблицу (`table.len() == 0`) функция должна запаниковать с текстом `"insert in empty kolhoz-table"`.

### `get_one_or_default`

```rust
pub fn get_one_or_default(table: &Vec<Vec<(Key, Data)>>, key: &Key, default_value: &Data) -> &Data;
```

Ищет значение по ключу `key` в хеш-таблице `table`.
Если значение присутствует, то нужно вернуть ссылку на него.
Если значений несколько, то можно вернуть произвольное значение по данному ключу.
Если значений по данному ключу нет, то нужно вернуть дефолтное значение `default_value`.

### `multi_get`

```rust
pub fn multi_get(table: &Vec<Vec<(Key, Data)>>, keys: &Vec<Key>) -> Vec<(&Key, Vec<&Data>)>;
```

Возвращает список всех значений по запрошенным ключам `keys`.
Например, если в хеш-таблице лежали значения:
```json
{
    "yandex.ru": "77.88.55.66",
    "yandex.ru": "5.255.255.50",
    "google.com": "216.58.209.206",
}
```
и были запрошены значения по ключам `["google.com", "yahoo.com", "yandex.ru"]`, то результатом будет
```rust
vec![
    ("google.com", vec!["216.58.209.206"]),
    ("yahoo.com",  vec![]),
    ("yandex.ru",  vec!["77.88.55.66", "5.255.255.50"]),
]
```

*Пожелание*. Попробуйте избежать от дублирования кода в функциях `get_one_or_default` и `multi_get`, реализовав общую логику один раз.

### `find_keys_of_data` aka killer-feature of Kolhoz HashMap

```rust
pub fn find_keys_of_data(table: &Vec<Vec<(Key, Data)>>, value: &Data) -> Vec<&Key>;
```

Возвращает все ключи, по которым хранятся данные равные `value`.

### `resize`

```rust
pub fn resize(table: &mut Vec<Vec<(Key, Data)>>, new_len: usize);
```

Изменяет размер таблицы на `new_len`.
При этом хеш-таблица должна быть перехеширована.
То есть номер бакета каждого элемента должен быть пересчитан.

__*Challenge*__. Попробуйте обойтись без заведения вспомогательных векторов и клонирований.

## Тесты

Тесты в этот раз находятся в файле [src/lib.rs](src/lib.rs), а не в директории `tests`.

## Дополнительное задание

После написания решения подумайте, почему данная вариация хеш-таблицы называется kolhoz:

- с точки зрения алгоритма
- с точки зрения реализации
